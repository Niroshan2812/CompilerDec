%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* forward declaration for lexer generated by flex */
int yylex(void);
void yyerror (cosnt char *s);

/* keep current line number */
extern int line_num; 
%}

/* the sementic part (not include here)*/
%union {
    char *lexeme;
}

/* multi-character or keyword tokens (carry lexeme when needed)*/
%token <lexeme> ID INTEGER FLOAT

/* Keywords */
%token IF ELSE FUNC WHILE RETURN READ WRITE CLASS IMPLEMENT
%token INTEGER_K FLOAT_K SELF ISA CONSTRUCT PRIVATE THEN PUBLIC LOCAL
%token VOID ATTRIBUTE WRITE_K /* NOTE: WRITE already above; keep a consistent name */
%token READ_K 

/* oPERATORS  */
%token ASSIGN  /* ":=" */
%token ARROW   /* "=>" */
%token LE      /* "<=" */
%token GE      /* ">=" */
%token EQ      /* "==" */
%token NE      /* "<>" */
%token AND_OP  /* "and" */
%token OR_OP   /* "or" */
%token NOT_OP  /* "not" */

/* Some keyword names chosen to avoid conflict with other token names */
%token ELSE_K CLASS_K RETURN_K WHILE_K

%%
/* Start symbol: repeatedly accept tokens (demo-style) */
program:
    /* empty */
  | program token
  ;

/* token rule prints each recognized token with lexeme or line number */

token:
ID          { printf("Token: ID, lexeme=\"%s\", line=%d\n", $1, line_num); free($1); }
| INTEGER     { printf("Token: INTEGER, lexeme=\"%s\", line=%d\n", $1, line_num); free($1); }
| FLOAT       { printf("Token: FLOAT, lexeme=\"%s\", line=%d\n", $1, line_num); free($1); }

/* keyword */
| IF          { printf("Token: IF, line=%d\n", line_num); }
| ELSE        { printf("Token: ELSE, line=%d\n", line_num); }
| FUNC        { printf("Token: FUNC, line=%d\n", line_num); }
| WHILE       { printf("Token: WHILE, line=%d\n", line_num); }
| RETURN      { printf("Token: RETURN, line=%d\n", line_num); }
| READ        { printf("Token: READ, line=%d\n", line_num); }
| WRITE       { printf("Token: WRITE, line=%d\n", line_num); }
| CLASS       { printf("Token: CLASS, line=%d\n", line_num); }
| IMPLEMENT   { printf("Token: IMPLEMENT, line=%d\n", line_num); }

| INTEGER_K   { printf("Token: INTEGER_K, line=%d\n", line_num); }
| FLOAT_K     { printf("Token: FLOAT_K, line=%d\n", line_num); }
| SELF        { printf("Token: SELF, line=%d\n", line_num); }
| ISA         { printf("Token: ISA, line=%d\n", line_num); }
| CONSTRUCT   { printf("Token: CONSTRUCT, line=%d\n", line_num); }
| PRIVATE     { printf("Token: PRIVATE, line=%d\n", line_num); }
| THEN        { printf("Token: THEN, line=%d\n", line_num); }
| PUBLIC      { printf("Token: PUBLIC, line=%d\n", line_num); }
| LOCAL       { printf("Token: LOCAL, line=%d\n", line_num); }
| VOID        { printf("Token: VOID, line=%d\n", line_num); }
| ATTRIBUTE   { printf("Token: ATTRIBUTE, line=%d\n", line_num); }


/* oPERATORS MULTI CHARACTER */
| ASSIGN      { printf("Token: ASSIGN (':='), line=%d\n", line_num); }
  | ARROW       { printf("Token: ARROW ('=>'), line=%d\n", line_num); }
  | LE          { printf("Token: LE ('<='), line=%d\n", line_num); }
  | GE          { printf("Token: GE ('>='), line=%d\n", line_num); }
  | EQ          { printf("Token: EQ ('=='), line=%d\n", line_num); }
  | NE          { printf("Token: NE ('<>'), line=%d\n", line_num); }
  | AND_OP      { printf("Token: AND_OP ('and'), line=%d\n", line_num); }
  | OR_OP       { printf("Token: OR_OP ('or'), line=%d\n", line_num); }
  | NOT_OP      { printf("Token: NOT_OP ('not'), line=%d\n", line_num); }

  /* sINGLE CHARACTER OPERATORS */
   | ';'         { printf("Token: SEMICOLON ';', line=%d\n", line_num); }
  | ','         { printf("Token: COMMA ',', line=%d\n", line_num); }
  | '('         { printf("Token: LPAREN '(', line=%d\n", line_num); }
  | ')'         { printf("Token: RPAREN ')', line=%d\n", line_num); }
  | '{'         { printf("Token: LBRACE '{', line=%d\n", line_num); }
  | '}'         { printf("Token: RBRACE '}', line=%d\n", line_num); }
  | '['         { printf("Token: LBRACK '[', line=%d\n", line_num); }
  | ']'         { printf("Token: RBRACK ']', line=%d\n", line_num); }
  | ':'         { printf("Token: COLON ':', line=%d\n", line_num); }
  | '.'         { printf("Token: DOT '.', line=%d\n", line_num); }
  | '+'         { printf("Token: PLUS '+', line=%d\n", line_num); }
  | '-'         { printf("Token: MINUS '-', line=%d\n", line_num); }
  | '*'         { printf("Token: STAR '*', line=%d\n", line_num); }
  | '/'         { printf("Token: SLASH '/', line=%d\n", line_num); }
  | '<'         { printf("Token: LT '<', line=%d\n", line_num); }
  | '>'         { printf("Token: GT '>', line=%d\n", line_num); }

  ;
%%

int main  (void){
    if (yyparse()==0){

    }
    return 0;
}

void yyerror(const char *s){
    fprintf(stderr, "parse error (line %d): %s\n", line_num, s);
}