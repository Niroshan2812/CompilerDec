/* parser.y - completed Bison grammar for the lexical analyzer demo */

%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* forward declaration for lexer generated by flex */
int yylex(void);
void yyerror(const char *s);

/* Keep current line number (updated in scanner.l) */
extern int line_num;
%}

/* the semantic value only needs a lexeme string for this task */
%union {
    char *lexeme;
}

/* Multi-character / keyword tokens (carry lexeme when needed) */
%token <lexeme> ID INTEGER FLOAT

/* Keywords */
%token IF ELSE FUNC WHILE RETURN READ WRITE CLASS IMPLEMENT
%token INTEGER_K FLOAT_K SELF ISA CONSTRUCT PRIVATE THEN PUBLIC LOCAL
%token VOID ATTRIBUTE WRITE_K /* NOTE: WRITE already above; keep a consistent name */
%token READ_K /* duplicate protection */

/* Operators (multi-char) */
%token ASSIGN  /* ":=" */
%token ARROW   /* "=>" */
%token LE      /* "<=" */
%token GE      /* ">=" */
%token EQ      /* "==" */
%token NE      /* "<>" */
%token AND_OP  /* "and" */
%token OR_OP   /* "or" */
%token NOT_OP  /* "not" */

/* Some keyword names chosen to avoid conflict with other token names */
%token ELSE_K CLASS_K RETURN_K WHILE_K

%%

/* Start symbol: repeatedly accept tokens (demo-style) */
program:
    /* empty */
  | program token
  ;

/* token rule prints each recognized token with lexeme or line number */
token:
    ID          { printf("Token: ID, lexeme=\"%s\", line=%d\n", $1, line_num); free($1); }
  | INTEGER     { printf("Token: INTEGER, lexeme=\"%s\", line=%d\n", $1, line_num); free($1); }
  | FLOAT       { printf("Token: FLOAT, lexeme=\"%s\", line=%d\n", $1, line_num); free($1); }

  /* Keywords */
  | IF          { printf("Token: IF, line=%d\n", line_num); }
  | ELSE        { printf("Token: ELSE, line=%d\n", line_num); }
  | FUNC        { printf("Token: FUNC, line=%d\n", line_num); }
  | WHILE       { printf("Token: WHILE, line=%d\n", line_num); }
  | RETURN      { printf("Token: RETURN, line=%d\n", line_num); }
  | READ        { printf("Token: READ, line=%d\n", line_num); }
  | WRITE       { printf("Token: WRITE, line=%d\n", line_num); }
  | CLASS       { printf("Token: CLASS, line=%d\n", line_num); }
  | IMPLEMENT   { printf("Token: IMPLEMENT, line=%d\n", line_num); }

  | INTEGER_K   { printf("Token: INTEGER_K, line=%d\n", line_num); }
  | FLOAT_K     { printf("Token: FLOAT_K, line=%d\n", line_num); }
  | SELF        { printf("Token: SELF, line=%d\n", line_num); }
  | ISA         { printf("Token: ISA, line=%d\n", line_num); }
  | CONSTRUCT   { printf("Token: CONSTRUCT, line=%d\n", line_num); }
  | PRIVATE     { printf("Token: PRIVATE, line=%d\n", line_num); }
  | THEN        { printf("Token: THEN, line=%d\n", line_num); }
  | PUBLIC      { printf("Token: PUBLIC, line=%d\n", line_num); }
  | LOCAL       { printf("Token: LOCAL, line=%d\n", line_num); }
  | VOID        { printf("Token: VOID, line=%d\n", line_num); }
  | ATTRIBUTE   { printf("Token: ATTRIBUTE, line=%d\n", line_num); }

  /* Operators (multi-char) */
  | ASSIGN      { printf("Token: ASSIGN (':='), line=%d\n", line_num); }
  | ARROW       { printf("Token: ARROW ('=>'), line=%d\n", line_num); }
  | LE          { printf("Token: LE ('<='), line=%d\n", line_num); }
  | GE          { printf("Token: GE ('>='), line=%d\n", line_num); }
  | EQ          { printf("Token: EQ ('=='), line=%d\n", line_num); }
  | NE          { printf("Token: NE ('<>'), line=%d\n", line_num); }
  | AND_OP      { printf("Token: AND_OP ('and'), line=%d\n", line_num); }
  | OR_OP       { printf("Token: OR_OP ('or'), line=%d\n", line_num); }
  | NOT_OP      { printf("Token: NOT_OP ('not'), line=%d\n", line_num); }

  /* Single-character punctuation/operators: return their ascii code from lexer
     In Bison rules below we match by literal characters; printing identifies them. */
  | ';'         { printf("Token: SEMICOLON ';', line=%d\n", line_num); }
  | ','         { printf("Token: COMMA ',', line=%d\n", line_num); }
  | '('         { printf("Token: LPAREN '(', line=%d\n", line_num); }
  | ')'         { printf("Token: RPAREN ')', line=%d\n", line_num); }
  | '{'         { printf("Token: LBRACE '{', line=%d\n", line_num); }
  | '}'         { printf("Token: RBRACE '}', line=%d\n", line_num); }
  | '['         { printf("Token: LBRACK '[', line=%d\n", line_num); }
  | ']'         { printf("Token: RBRACK ']', line=%d\n", line_num); }
  | ':'         { printf("Token: COLON ':', line=%d\n", line_num); }
  | '.'         { printf("Token: DOT '.', line=%d\n", line_num); }
  | '+'         { printf("Token: PLUS '+', line=%d\n", line_num); }
  | '-'         { printf("Token: MINUS '-', line=%d\n", line_num); }
  | '*'         { printf("Token: STAR '*', line=%d\n", line_num); }
  | '/'         { printf("Token: SLASH '/', line=%d\n", line_num); }
  | '<'         { printf("Token: LT '<', line=%d\n", line_num); }
  | '>'         { printf("Token: GT '>', line=%d\n", line_num); }

  ;

%%

int main(void) {
    /* Start parsing/lexing */
    if (yyparse() == 0) {
        /* success */
    }
    return 0;
}

void yyerror(const char *s) {
    fprintf(stderr, "Parse error (line %d): %s\n", line_num, s);
}
